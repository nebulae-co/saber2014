---
title: "Saber 11 2014"
author: "Datum"
output: html_document
---

```{r setup, include = FALSE}
rm(list = ls())

library("knitr")
library("FactoMineR")
library("magrittr")
library("dplyr")
library("ggplot2")

opts_chunk$set(echo = FALSE,
               results = "hide",
               warning = FALSE,
               fig.path = "./Figures/",
               fig.keep = "last")
```

```{r data}
load("./data/Saber11.RData")
```

```{r municipios}
municipios_50 <- Saber11 %>%
  dplyr::group_by(MUNI_RESIDE) %>%
  dplyr::summarise(N = n()) %>%
  dplyr::filter(N > 50) %>%
  dplyr::mutate(MUNI_RESIDE = as.character(MUNI_RESIDE))

nuevo_saber_11 <- Saber11 %>%
  dplyr::filter(MUNI_RESIDE %in% municipios_50$MUNI_RESIDE) %>%
  dplyr::select(MUNI_RESIDE, DEPA_RESIDE, TOTAL)

factores <- sapply(X = nuevo_saber_11, FUN = is.factor)
nuevo_saber_11[, factores] %<>% lapply(FUN = factor)

rm(list = setdiff(ls(), c("nuevo_saber_11", "municipios_50")))
```

```{r percentiles}
percentiles <- nuevo_saber_11 %$%
  tapply(X = TOTAL, INDEX = MUNI_RESIDE, FUN = quantile, probs = seq(0, 1, 0.1)) %>%
  do.call(what = "rbind", args = .) %>%
  as.data.frame
```

```{r ecdf}
totales_ordenados <- nuevo_saber_11$TOTAL %>% unique %>% sort

ecdf_municipios <- nuevo_saber_11 %$%
  tapply(X = TOTAL, INDEX = MUNI_RESIDE, FUN = ecdf)

ecdf <- sapply(X = ecdf_municipios, FUN = function(x, y){x(y)},
  y = totales_ordenados) %>% t %>% as.data.frame
```

```{r ecdf_distance}
# Euclidian distance of the evaluated vectors of ecdf's
dist_matrix <- dist(ecdf)
```

```{r distancias_pocos_datos}
# Funcion de distancia entre vectores para aplicar a los totales de los municipios

fun_distance <- function(a, b, ...){
  valores <- sort(c(a, b))
  n <- length(valores)
  diff_x <- diff(valores)

  diff_2_y <- sapply(X = 1:(n-1),
                     FUN = function(x, v, a, b){
                       abs(mean(v[x] >= a) - mean(v[x] >= b))
                     },
                     v = valores, a = a, b = b,
                     USE.NAMES = FALSE)

  drop(diff_x %*% diff_2_y)^2
}

# Partir los totales por municipio

totales <- nuevo_saber_11 %$% split(x = TOTAL, f = MUNI_RESIDE)

# Calcular la matriz de distancias

dist_matrix <- matrix(nrow = nrow(municipios_50), ncol = nrow(municipios_50),
                      dimnames = list(names(totales), names(totales)))

dist_matrix[lower.tri(dist_matrix)] <- totales %>%
  combn(m = 2, FUN = function(x){fun_distance(x[[1]], x[[2]])}) %>%
  as.dist
```

```{r agrupamiento, cache = TRUE}
clustering_municipios <- dist_matrix %>%
  hclust(method = "ward.D") # Agruparlo con el método de ward
grupos_municipios <- clustering_municipios %>% cutree(k = 5)  %>%
  factor(levels = c(2, 1, 4, 5, 3), labels=c("Pionero", "Suficiente", "Regular", "Insuficiente", "Prioritario"))

ggplot(data.frame(grupos_municipios = grupos_municipios), aes(factor(1), fill = grupos_municipios)) +
  geom_bar(width = 1) +
  coord_polar(theta = "y")
ggsave("pastel_grupos.png", bg = "transparent")
```

```{r ACP}
ACP_de_municipios <- ecdf %>%
  FactoMineR::PCA(graph = FALSE)

RESULTADO <- data.frame(x = ACP_de_municipios$ind$coord[, 1],
                        y = ACP_de_municipios$ind$coord[, 2],
                        N = municipios_50$N,
                        grupo = grupos_municipios)

qplot(x = x, y = y, size = N, colour = grupo, data = RESULTADO)
ggsave("ACP_municipios_grupos.png")
#plot(ACP_de_municipios, label="none")
#plot(ACP_de_municipios, choix = "var") #para ver la correlación de las variables
```