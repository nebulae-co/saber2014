---
title: "Saber 11 2014"
author: "Datum"
output: html_document
---

```{r setup, include = FALSE}
rm(list = ls())

library("knitr")
library("FactoMineR")
library("magrittr")
library("dplyr")
library("ggplot2")

opts_chunk$set(include = FALSE)

# options(stringsAsFactors = FALSE)
```

```{r data}
load("./data/Saber11.RData")
```

```{r municipios}
municipios_50 <- Saber11 %>%
  dplyr::group_by(MUNI_RESIDE) %>%
  dplyr::summarise(N = n()) %>%
  dplyr::filter(N > 50 & N < 60) %>%
  dplyr::mutate(MUNI_RESIDE = as.character(MUNI_RESIDE))

cuantos_municipios <- municipios_50$MUNI_RESIDE %>%
  length

nuevo_saber_11 <- Saber11 %>%
  dplyr::filter(MUNI_RESIDE %in% municipios_50$MUNI_RESIDE) %>%
  dplyr::select(MUNI_RESIDE, DEPA_RESIDE, TOTAL)

factores <- sapply(X = nuevo_saber_11, FUN = is.factor)
nuevo_saber_11[, factores] %<>% lapply(FUN = factor)

rm(list = setdiff(ls(), c("nuevo_saber_11", "municipios_50", "cuantos_municipios")))
```

```{r agrupamiento, cache = TRUE}
# Funcion de distancia entre funciones para aplicar a las ecdf

fun_distance <- function(a, b, ...){
  
  valores <- sort(c(a, b))
  
  cuantos_valores <- length(valores)
  
  diferencias_en_x <- valores[2:cuantos_valores] - valores[1:(cuantos_valores - 1)]

  diferencias_cuadradas_en_y <- NULL
    
  for(i in 1:(cuantos_valores - 1)){
    diferencias_cuadradas_en_y[i] <- (mean(valores[i] >= a) - mean(valores[i] >= b))^2
  }
  diferencias_en_x %*% diferencias_cuadradas_en_y
  
}


#partir los totales por municipio

totales_por_municipio <- split(x = nuevo_saber_11$TOTAL, f = nuevo_saber_11$MUNI_RESIDE)

# Calcular la matriz de distancias
cluster_municipios <- municipios_50$MUNI_RESIDE %>% #nombres de los municipios
  expand.grid(.,., stringsAsFactors = FALSE) %>% #municipios x municipios (producto externo) todas las parejas posibles
  apply(MARGIN = 1, FUN = function(x){ fun_distance(totales_por_municipio[[x[1]]], totales_por_municipio[[x[2]]])}) %>% #aplicar la función de distancias a todas las parejas posibles
  matrix(nrow = cuantos_municipios, ncol = cuantos_municipios, dimnames = list(municipios_50$MUNI_RESIDE, municipios_50$MUNI_RESIDE)) %>% #meter el resultado en una matriz
  dist %>% #convertirlo a distancia
  hclust(method = "ward.D") %>% #agruparlo con el método de ward
  cutree(k = 4) #formar 4 clases

```

```{r ACP, include=TRUE}
# puse 101 columnas, voy a evaluar cada municipio en todos sus percentiles
numero_de_columnas <- 101

percentiles <- seq(from = 0, to = 1, length.out = numero_de_columnas)

ACP_de_municipios <- nuevo_saber_11 %$%
  tapply(X = TOTAL, INDEX = MUNI_RESIDE, FUN = quantile, probs = percentiles) %>%
  do.call(what = "rbind", args = .) %>%
  FactoMineR::PCA(graph = FALSE)

#por ahora mientras están los grupos
RESULTADO <- data.frame(x = ACP_de_municipios$ind$coord[, 1],
                        y = ACP_de_municipios$ind$coord[, 2],
                        N = municipios_50$N,
                        grupo = factor(cluster_municipios))

qplot(x = x, y = y, size = N, colour = grupo, data = RESULTADO)

#plot(ACP_de_municipios, label="none")
#plot(ACP_de_municipios, choix = "var") #para ver la correlación de las variables
```