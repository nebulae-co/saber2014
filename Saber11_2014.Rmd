---
title: "Saber 11 2014"
author: "Datum"
output: html_document
---

```{r setup, include = FALSE}
rm(list = ls())

library("knitr")
library("FactoMineR")
library("magrittr")
library("dplyr")
library("ggplot2")

opts_chunk$set(echo = FALSE, 
               results = "hide",
               warning = FALSE, 
               fig.path = "./Figures/", 
               fig.keep = "last")
```

```{r data}
load("./data/Saber11.RData")
```

```{r municipios}
municipios_50 <- Saber11 %>%
  dplyr::group_by(MUNI_RESIDE) %>%
  dplyr::summarise(N = n()) %>%
  dplyr::filter(N > 50) %>%
  dplyr::mutate(MUNI_RESIDE = as.character(MUNI_RESIDE))

nuevo_saber_11 <- Saber11 %>%
  dplyr::filter(MUNI_RESIDE %in% municipios_50$MUNI_RESIDE) %>%
  dplyr::select(MUNI_RESIDE, DEPA_RESIDE, TOTAL)

factores <- sapply(X = nuevo_saber_11, FUN = is.factor)
nuevo_saber_11[, factores] %<>% lapply(FUN = factor)

rm(list = setdiff(ls(), c("nuevo_saber_11", "municipios_50")))
```




```{r ernesto_muchos_datos}

# puse 101 columnas, voy a evaluar cada municipio en todos sus percentiles
numero_de_columnas <- 101

percentiles <- seq(from = 0, to = 1, length.out = numero_de_columnas)

ernesto <- nuevo_saber_11 %$%
  tapply(X = TOTAL, INDEX = MUNI_RESIDE, FUN = quantile, probs = percentiles) %>%
  do.call(what = "rbind", args = .)

```


```{r ernesto_pocos_datos}
#falta optimizar, de hecho lo saqué del código primigenio

cuantos_municipios <- municipios_50 %$% N %>% length
cuantos_muchachos <- nuevo_saber_11 %$% TOTAL %>% length

totales_ordenados<-nuevo_saber_11 %$% TOTAL %>%
  sort

ernesto<-matrix(nrow = cuantos_municipios, ncol = cuantos_muchachos)

for(i in 1:cuantos_municipios){
for(j in 1: cuantos_muchachos){
ernesto[i, j] <- totales_ordenados[j] >= nuevo_saber_11$TOTAL[which(nuevo_saber_11$MUNI_RESIDE==municipios_50$MUNI_RESIDE[i])] %>%
  mean
}
}

ernesto %<>% as.data.frame 
  
```


```{r distancias_muchos_datos}

dist_matrix <- dist(ernesto)

```


```{r distancias_pocos_datos}
# Funcion de distancia entre vectores para aplicar a los totales de los municipios

fun_distance <- function(a, b, ...){
  valores <- sort(c(a, b))
  n <- length(valores)
  diff_x <- diff(valores)

  diff_2_y <- sapply(X = 1:(n-1),
                     FUN = function(x, v, a, b){
                       abs(mean(v[x] >= a) - mean(v[x] >= b)) 
                     },
                     v = valores, a = a, b = b,
                     USE.NAMES = FALSE)
  
  drop(diff_x %*% diff_2_y)^2
}

# Partir los totales por municipio

totales <- nuevo_saber_11 %$% split(x = TOTAL, f = MUNI_RESIDE)

# Calcular la matriz de distancias

dist_matrix <- matrix(nrow = nrow(municipios_50), ncol = nrow(municipios_50),
                      dimnames = list(names(totales), names(totales)))

dist_matrix[lower.tri(dist_matrix)] <- totales %>%
  combn(m = 2, FUN = function(x){fun_distance(x[[1]], x[[2]])}) %>%
  as.dist

```


```{r agrupamiento, cache = TRUE}
clustering_municipios <- dist_matrix %>%
  hclust(method = "ward.D") # Agruparlo con el método de ward
grupos_municipios <- clustering_municipios %>% cutree(k = 4)  %>%
  factor
```

```{r ACP}
ACP_de_municipios <- ernesto %>%
  FactoMineR::PCA(graph = FALSE)

RESULTADO <- data.frame(x = ACP_de_municipios$ind$coord[, 1],
                        y = ACP_de_municipios$ind$coord[, 2],
                        N = municipios_50$N,
                        grupo = grupos_municipios)

qplot(x = x, y = y, size = N, colour = grupo, data = RESULTADO)

#plot(ACP_de_municipios, label="none")
#plot(ACP_de_municipios, choix = "var") #para ver la correlación de las variables
```